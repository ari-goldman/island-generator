// Adapted from this paper:
// https://www.firespark.de/resources/downloads/implementation%20of%20a%20methode%20for%20hydraulic%20erosion.pdf

#version 430 core

layout(local_size_x = 512, local_size_y = 1, local_size_z = 1) in;
layout(r32f, binding = 0) uniform image2D heightTex;
layout(std430, binding = 1) buffer Randoms {
    int random[];
};

uniform ivec2 texSize;
uniform float time;



bool inBounds(ivec2 pos) {
    if(pos.x < 0 || pos.x >= texSize.x || pos.y < 0 || pos.y >= texSize.y) {
        return false;
    } else {
        return true;
    }
}


float rand (vec2 st) {
    return fract(sin(dot(st.xy,
                         vec2(12.9898,78.233)))*
        43758.5453123);
}

vec2 getRandomTexCoord() {
    // Use the invocation ID and a fixed seed to generate random numbers
    float randX = rand(vec2(float(gl_GlobalInvocationID.x), 71.456 * time));
    float randY = rand(vec2(float(gl_GlobalInvocationID.x), 82.713 * time));

    // Scale the random numbers to the heightTex dimensions
    float x = randX * float(texSize.x);
    float y = randY * float(texSize.y);

    if(inBounds(ivec2(x, y))) return vec2(x, y);
    else vec2(texSize) / 2.0;
}

vec3 getGradientAndHeight(vec2 pos) {
    ivec2 intPos = ivec2(pos);


    // position in cell
    vec2 cellPos = vec2(pos - intPos);

    // get corners of cell
    float heightNW = imageLoad(heightTex, intPos + ivec2(0, 0)).r;
    float heightNE = imageLoad(heightTex, intPos + ivec2(1, 0)).r;
    float heightSW = imageLoad(heightTex, intPos + ivec2(0, 1)).r;
    float heightSE = imageLoad(heightTex, intPos + ivec2(1, 1)).r;

    vec3 gradientHeight = vec3(
        (heightNE - heightNW) * (1 - cellPos.x) + (heightSE - heightSW) * cellPos.x,
        // (heightNW - heightSW) * (1 - cellPos.y) + (heightNE - heightSE) * cellPos.y,
        (heightSW - heightNW) * (1 - cellPos.y) + (heightSE - heightNE) * cellPos.y,
        heightNW * (1 - cellPos.x) * (1 - cellPos.y)
            + (heightNE * cellPos.x * (1 - cellPos.y))
            + (heightSW * (1 - cellPos.x) * cellPos.y)
            + (heightSE * cellPos.x * cellPos.y)
    );

    return gradientHeight;
}


void depositBilinearly(vec2 pos, float toDeposit) {
    ivec2 intPos = ivec2(pos);


    // position in cell
    vec2 cellPos = vec2(pos - intPos);

    ivec2 NW = intPos + ivec2( 0, 0);
    ivec2 NE = intPos + ivec2( 1, 0);
    ivec2 SW = intPos + ivec2( 0, 1);
    ivec2 SE = intPos + ivec2( 1, 1);

    if(inBounds(NW)) {
        float heightNW = imageLoad(heightTex, NW).r;
        imageStore(heightTex, NW, vec4(heightNW + (toDeposit * (1.0 - cellPos.x) * (1.0 - cellPos.y)), 0.0, 0.0, 1.0));
    }

    if(inBounds(NE)) {
        float heightNE = imageLoad(heightTex, NE).r;
        imageStore(heightTex, NE, vec4(heightNE + (toDeposit *        cellPos.x  * (1.0 - cellPos.y)), 0.0, 0.0, 1.0));
    }

    if(inBounds(SW)) {
        float heightSW = imageLoad(heightTex, SW).r;
        imageStore(heightTex, SW, vec4(heightSW + (toDeposit * (1.0 - cellPos.x) *        cellPos.y ), 0.0, 0.0, 1.0));
    }

    if(inBounds(SE)) {
        float heightSE = imageLoad(heightTex, SE).r;
        imageStore(heightTex, SE, vec4(heightSE + (toDeposit *        cellPos.x  *        cellPos.y ), 0.0, 0.0, 1.0));
    }

}

#define BRUSH_RADIUS 3
const float brushWeights[(BRUSH_RADIUS * 2 + 1) * (BRUSH_RADIUS * 2 + 1)] = float[(BRUSH_RADIUS * 2 + 1) * (BRUSH_RADIUS * 2 + 1)](
    0.00000000, 0.00000000, 0.00000000, 0.00000000, 0.00000000, 0.00000000, 0.00000000,
    0.00000000, 0.00609692, 0.02714669, 0.03553547, 0.02714669, 0.00609692, 0.00000000,
    0.00000000, 0.02714669, 0.05635167, 0.07107095, 0.05635167, 0.02714669, 0.00000000,
    0.00000000, 0.03553547, 0.07107095, 0.10660642, 0.07107095, 0.03553547, 0.00000000,
    0.00000000, 0.02714669, 0.05635167, 0.07107095, 0.05635167, 0.02714669, 0.00000000,
    0.00000000, 0.00609692, 0.02714669, 0.03553547, 0.02714669, 0.00609692, 0.00000000,
    0.00000000, 0.00000000, 0.00000000, 0.00000000, 0.00000000, 0.00000000, 0.00000000
);

const float Kd = 0.3; // deposition rate
const float Kc = 4;  // sediment carrying capacity (sediment/water)
const float Ks = 0.1; // soil softness

const float initVel = 5.0;
const float initWater = 4.0;

const int iterations = 20;

const float intertia = 0.05;
const float evaporation = 0.01;

const float minSedimentCapacity = 0.001;

const float gravity = 4;


void main() {
    vec2 pos;
    vec2 dir;
    float vel;
    float water;
    float sediment;

    uint tid = gl_GlobalInvocationID.x
                 + gl_GlobalInvocationID.y * (gl_NumWorkGroups.x*gl_WorkGroupSize.x)
                 + gl_GlobalInvocationID.z * (gl_NumWorkGroups.x*gl_WorkGroupSize.x * gl_NumWorkGroups.y*gl_WorkGroupSize.y);


    int randomIndex = random[tid % 512];
    pos = ivec2(randomIndex % texSize.x, randomIndex / texSize.x);

    dir = vec2(0.0);
    vel = initVel;
    water = initWater;
    sediment = 0.0;

    for(int i = 0; i < iterations; i++) {
        vec2 oldPos = pos;
        vec3 gradientHeight = getGradientAndHeight(pos);

        // update position
        dir = (dir * intertia) - (gradientHeight.xy * (1 - intertia));
        dir = normalize(dir + 1e-5);
        pos += dir;

        // out of bounds
        if((dir.x == 0 && dir.y == 0) || pos.x < 1 || pos.x > texSize.x - 1 || pos.y < 1 || pos.y > texSize.y - 1) {
            break;
        }

        float newHeight = getGradientAndHeight(pos).z;
        float dHeight = newHeight - gradientHeight.z;
        float sedimentCapacity = max(-dHeight * vel * water * Kc, minSedimentCapacity);

        // uphill or over capacity
        if(sediment > sedimentCapacity || dHeight > 0) {
            float toDeposit;
            if(dHeight > 0) {
                // if uphill, fill the hole
                toDeposit = min(dHeight, sediment);
            } else {
                // if downhill, deposit a fraction of sediment
                toDeposit = (sediment - sedimentCapacity) * Kd;
            }


            // add sediment to corners of node based off bilinear interpolation
            memoryBarrierImage();
//             depositBilinearly(oldPos, toDeposit);
            sediment -= toDeposit;
        } else { // downhill
            float toErode = min((sedimentCapacity - sediment) * Ks, -dHeight);

            memoryBarrierImage();
            for(int x = -BRUSH_RADIUS; x <= BRUSH_RADIUS; x++) {
                for(int y = -BRUSH_RADIUS; y <= BRUSH_RADIUS; y++) {
                    depositBilinearly(oldPos + vec2(x, y), -toErode * brushWeights[(x + BRUSH_RADIUS) * (BRUSH_RADIUS * 2 + 1) + (y + BRUSH_RADIUS)]);

                }
            }
            sediment += toErode;
        }

        vel = sqrt((vel * vel) + dHeight * gravity);
        water = water * (1 - evaporation);
    }
}