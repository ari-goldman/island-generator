#version 430 core

layout(quads, fractional_even_spacing, ccw) in;

#define TWO_PI 6.28318530718

in vec4 tcPos[];

out vec3 WorldNormal;
out vec3 View;
out vec3 Normal;
out vec3 WorldPos;
out vec3 Light;


uniform float time;
uniform mat4 view;
uniform mat4 proj;
uniform mat3 norm;
uniform vec3 sunDir;

const float amplitudes[4] = { 0.021, 0.019, 0.012, 0.01 };
const float wavelengths[4] = { 2.0, 1.0, 0.5, 0.25 };
const float speeds[4] = { 0.4, 0.7, 0.9, 1.3 };
const vec2 dirs[4] = {
    vec2(1.0, 0.32),
    vec2(-0.6, 1.0),
    vec2(-1.0, 1.7),
    vec2(1.54, -1.0)
};

// From GPU Gems 1
// yes I have the physical book :)
float wave(vec2 pos) {
    float height = 0.0;
    for (int i = 0; i < 4; ++i) {
        float waveNumber = TWO_PI / wavelengths[i];
        float amplitude = amplitudes[i];
        float speed = speeds[i];
        vec2 dir = normalize(dirs[i]);
        float k = 1.0 + (i * 0.5);

        float dH = sin(dot(pos, dir) * waveNumber + time * speed);
        dH += 1.0;
        dH /= 2.0;
        dH = pow(dH, k);
        dH = 2 * amplitude * dH;
        height += dH;
    }

    return height;
}

vec3 normal(vec2 pos) {
    float dX = 0.0;
    for (int i = 0; i < 4; ++i) {
        float waveNumber = TWO_PI / wavelengths[i];
        float amplitude = amplitudes[i];
        float speed = speeds[i];
        vec2 dir = normalize(dirs[i]);
        float k = 1.0 + (i * 0.5);

        float dH = sin(dot(pos, dir) * waveNumber + time * speed);
        dH += 1.0;
        dH /= 2.0;
        dH = pow(dH, k - 1.0);
        dH *= amplitude;
        dH *= dir.x;
        dH *= k;
        dH *= cos(dot(pos, dir) * waveNumber + time * speed);

        dX += dH;
    }

    float dY = 0.0;
    for (int i = 0; i < 4; ++i) {
        float waveNumber = TWO_PI / wavelengths[i];
        float amplitude = amplitudes[i];
        float speed = speeds[i];
        vec2 dir = normalize(dirs[i]);
        float k = 1.0 + (i * 0.5);

        float dH = sin(dot(pos, dir) * waveNumber + time * speed);
        dH += 1.0;
        dH /= 2.0;
        dH = pow(dH, k - 1.0);
        dH *= amplitude;
        dH *= dir.y;
        dH *= k;
        dH *= cos(dot(pos, dir) * waveNumber + time * speed);

        dY += dH;
    }

    vec3 tangent = vec3(1.0, dX, 0.0);
    vec3 bitangent = vec3(0.0, dY, 1.0);

    return normalize(cross(tangent, bitangent));


}


// original normal method - switched to analytical normal calculation
// vec3 normal(vec2 pos) {
//     float height = wave(pos);
//     float heightX = wave(pos + vec2(0.01, 0.0));
//     float heightZ = wave(pos + vec2(0.0, 0.01));
//
//     vec3 tanX = normalize(vec3(0.01, heightX - height, 0.0));
//     vec3 tanZ = normalize(vec3(0.0, heightZ - height, 0.01));
//
//     return normalize(cross(tanZ, tanX));
// }

void main() {
    // linearly interpolate the four control points
    vec3 center = mix(
        mix(tcPos[0].xyz, tcPos[1].xyz, gl_TessCoord.x),
        mix(tcPos[3].xyz, tcPos[2].xyz, gl_TessCoord.x),
        gl_TessCoord.y
    );

    float height = wave(center.xz);

    WorldPos = vec3(center.x, center.y + height, center.z);

    WorldNormal = normal(center.xz);
    Normal = norm * WorldNormal;
    Light = vec3(view * vec4(normalize(sunDir * vec3(-1.0, 1.0, 1.0)), 1.0));


    gl_Position = proj * view * vec4(WorldPos, 1.0);
}


